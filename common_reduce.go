// Package mapreduce implements a distributed MapReduce framework
package mapreduce

import (
	"encoding/json"
	"log"
	"os"
)

// doReduce manages the reduce phase of a MapReduce job.
// It processes intermediate files generated by the map phase and produces final output.
//
// The reduce phase works as follows:
// 1. Reads intermediate files from all map tasks for this reducer
// 2. Groups values by key in memory using a hash map
// 3. For each key, applies the user's reduce function to its values
// 4. Writes the final key-value pairs to a single output file
//
// Parameters:
//   - jobName: Unique identifier for the MapReduce job
//   - reduceTaskNumber: Index of this reduce task (0-based)
//   - outFile: Path where the final output will be written
//   - nMap: Number of map tasks that generated intermediate files
//   - reduceF: User-defined function to process grouped values
//
// Error handling:
//   - Logs but continues if an intermediate file cannot be opened
//   - Fatally exits if the output file cannot be created
//
// The output is written in JSON format, with each line containing
// a key-value pair produced by the reduce function.
func doReduce(
	jobName JobParse,
	reduceTaskNumber int,
	outFile string,
	nMap int,
	reduceF func(string, []string) string,
) {
	// Create a map to store all values for each key
	// This aggregates results from all map tasks
	kvMap := make(map[string][]string)

	// Process intermediate files from each map task
	// Each file contains key-value pairs assigned to this reducer
	for i := 0; i < nMap; i++ {
		fileName := reduceName(jobName, i, reduceTaskNumber)
		file, err := os.Open(fileName)
		if err != nil {
			log.Printf("doReduce: open file %s error %v", fileName, err)
			continue // Skip this file but continue processing others
		}

		// Use a JSON decoder to read key-value pairs
		dec := json.NewDecoder(file)
		for {
			var kv KeyValue
			err = dec.Decode(&kv)
			if err != nil {
				break // End of file or error
			}
			// Append each value to the slice for its key
			kvMap[kv.Key] = append(kvMap[kv.Key], kv.Value)
		}
		file.Close()
	}

	// Create the final output file
	// This will contain the results of applying reduceF to each key's values
	file, err := os.Create(outFile)
	if err != nil {
		log.Fatalf("doReduce: create file %s error %v", outFile, err)
	}
	defer file.Close()
	enc := json.NewEncoder(file)

	// Process each key's values through the reduce function
	// Write each result as a JSON-encoded KeyValue pair
	for key, values := range kvMap {
		output := reduceF(key, values)
		enc.Encode(KeyValue{key, output})
	}
}
